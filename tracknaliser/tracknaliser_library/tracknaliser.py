import tracknaliser_library.class_definition as CD
from tracknaliser_library.input_validation import *
import sys 
""" 
tracknaliser.py collects useful functions from class_definition.py for access through a library style interface. 
The logic/structure description for each method, e.g. greentracks, is provided in detail within class_definition.py

tracknaliser.py also coordinates the use of validation and simplifies testing debugging by summarising the validation and method call within a few lines.

"""
def greentrack(start, end, verbose = False):
    """ Generate an input string to be used as a request input for the UCL track webapp.
    Parameters
    ----------
    start: two ints
        X Y coordinates as two seperate ints
    end: two ints
        X Y coordinates as two seperate ints

    Returns
    -------
    json_tracks
        a dictionary of all tracks from 'start' to 'end' generated by the webapp
    Examples
    --------
    >>> from tracknaliser import greentrack
    >>> greentrack([5,5], [100,100])
    json_tracks #dict returned 
    """

    if internet_check():
        None
    else:
        print("No internet connection")
        return "No internet connection"

    if user_input_coordinate_check(start) and user_input_coordinate_check(end):
        start = start.split() if "str" in str(type(start)) else start
        end = end.split() if "str" in str(type(end)) else end
        start_input = [int(start[0]),int(start[1])]
        end_input = [int(end[0]),int(end[1])]
        return CD.greentrack(start_input, end_input, verbose)
    else:
        print("Invalid input, unexpected character in coordinates. Only positive integers are allowed.")
        return "Invalid input, unexpected character in coordinates. Only positive integers are allowed."

def query_tracks(start = (0,0), end = (299,299), min_steps_straight = 1, max_steps_straight = -99, n_tracks = 300,save=True):
    if user_input_coordinate_check(start) and user_input_coordinate_check(end):
        start = start.split() if "str" in str(type(start)) else start
        end = end.split() if "str" in str(type(end)) else end
        return CD.query_tracks(start,end,min_steps_straight, max_steps_straight, n_tracks,save)
    else:
        print("Invalid input, unexpected character in coordinates. Only positive integers are allowed.")
        return "Invalid input, unexpected character in coordinates. Only positive integers are allowed."

#tracks = query_tracks(start=(12, 15), end=(25, 46), min_steps_straight=1, max_steps_straight=40, n_tracks=30, save=True)

# print(len(tracks))
# print("len tracks")
# print(tracks.fastest())
# print("tracks fastest")
# print(tracks.greenest())
# print("tracks greenest")
# print(tracks.shortest())
# print("tracks shortest")
# print(tracks.kmeans())
# print("tracks kmeans")

# a_track = tracks.get_track(10)
# print(a_track)
# print("a track")
# print(tracks.start, tracks.end, tracks.map_size, tracks.date )
# print("a track: start end map size date")
# print(tracks)
# print("tracks")

# print(len(a_track))
# print("len a track")
# print(a_track.corners())
# print("a track corners")
# print(a_track.visualise())
# print("a track visualise")
# print(a_track.co2(), a_track.distance() , a_track.time())
# print("a track co2 distance time")
# print(a_track.start, a_track.cc, a_track.road, a_track.terrain , a_track.elevation)
# print("a track start cc road terrain elevation")